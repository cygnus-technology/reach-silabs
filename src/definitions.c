/********************************************************************************************
 *    _ ____  ___             _         _     ___              _                        _
 *   (_)__ / | _ \_ _ ___  __| |_  _ __| |_  |   \ _____ _____| |___ _ __ _ __  ___ _ _| |_
 *   | ||_ \ |  _/ '_/ _ \/ _` | || / _|  _| | |) / -_) V / -_) / _ \ '_ \ '  \/ -_) ' \  _|
 *   |_|___/ |_| |_| \___/\__,_|\_,_\__|\__| |___/\___|\_/\___|_\___/ .__/_|_|_\___|_||_\__|
 *                                                                  |_|
 *                           -----------------------------------
 *                          Copyright i3 Product Development 2024
 *
 * MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * @file      definitions.c
 * @brief     A minimal implementation of Reach data access.  Auto-generated by a Python script.
 * @copyright 2023-2024 i3 Product Development. All Rights Reserved.
 *
 * Original Author: Chuck Peplinski
 * Script Author: Joseph Peplinski
 *
 * Generated with version 0.0.1 of c_code_generator.py
 *
 ********************************************************************************************/

#include "definitions.h"
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include "i3_log.h"
#include "app_version.h"
#include "cr_stack.h"

const cr_DeviceInfoResponse device_info = 
{
    .device_name        = "Thunderboard",
    .manufacturer       = "Silicon Labs",
    .device_description = "A demo of Reach features",
    // .protocol_version   = cr_ReachProtoVersion_CURRENT_VERSION,
    .services           = cr_ServiceIds_PARAMETER_REPO | cr_ServiceIds_FILES | cr_ServiceIds_COMMANDS | cr_ServiceIds_CLI | cr_ServiceIds_TIME
};

cr_ParameterValue sCr_param_val[NUM_PARAMS];

const cr_ParameterInfo param_desc[NUM_PARAMS] = {
    {
        .id                = PARAM_USER_DEVICE_NAME,
        .name              = "User Device Name",
        .which_desc        = cr_ParameterDataType_STRING + cr_ParameterInfo_uint32_desc_tag,
        .desc.string_desc.has_default_value = false,
        .desc.string_desc.default_value = "Test",
        .desc.string_desc.max_size = 26,
        .access            = cr_AccessLevel_READ_WRITE,
        .storage_location  = cr_StorageLocation_NONVOLATILE,
        .has_description   = true,
        .description       = "Advertised BLE name",
    },
    {
        .id                = PARAM_UPTIME,
        .name              = "Uptime",
        .which_desc         = cr_ParameterDataType_INT64 + cr_ParameterInfo_uint32_desc_tag,
        .access            = cr_AccessLevel_READ,
        .storage_location  = cr_StorageLocation_RAM,
        .desc.int64_desc.has_units = true,
        .desc.int64_desc.units = "milliseconds",
    },
    {
        .id                = PARAM_BUTTON_PRESSED,
        .name              = "Momentary Pushbutton",
        .which_desc        = cr_ParameterDataType_BOOL + cr_ParameterInfo_uint32_desc_tag,
        .desc.bool_desc.has_pei_id        = true,
        .desc.bool_desc.pei_id            = 4,
        .access            = cr_AccessLevel_READ,
        .storage_location  = cr_StorageLocation_RAM,
    },
    {
        .id                = PARAM_LED_ON,
        .name              = "LED On",
        .which_desc        = cr_ParameterDataType_BOOL + cr_ParameterInfo_uint32_desc_tag,
        .desc.bool_desc.has_pei_id        = true,
        .desc.bool_desc.pei_id            = 5,
        .access            = cr_AccessLevel_READ,
        .storage_location  = cr_StorageLocation_RAM,
    },
    {
        .id                = PARAM_IDENTIFY,
        .name              = "Identify",
        .which_desc        = cr_ParameterDataType_BOOL + cr_ParameterInfo_uint32_desc_tag,
        .desc.bool_desc.pei_id = 3,
        .access            = cr_AccessLevel_READ_WRITE,
        .storage_location  = cr_StorageLocation_RAM,
        .has_description   = true,
        .description       = "Blinks the yellow LED",
    },
    {
        .id                = PARAM_IDENTIFY_INTERVAL,
        .name              = "Identify Interval",
        .which_desc         = cr_ParameterDataType_FLOAT32 + cr_ParameterInfo_uint32_desc_tag,
        .access            = cr_AccessLevel_READ_WRITE,
        .storage_location  = cr_StorageLocation_NONVOLATILE,
        .has_description   = true,
        .description       = "Time between Identify blinks",
        .desc.float32_desc.has_units = true,
        .desc.float32_desc.units             = "seconds",
        .desc.float32_desc.has_range_min     = true,
        .desc.float32_desc.range_min         = 0.01,
        .desc.float32_desc.has_default_value = true,
        .desc.float32_desc.default_value     = 1,
        .desc.float32_desc.has_range_max     = true,
        .desc.float32_desc.range_max         = 60,
        .desc.float32_desc.has_precision = true,
        .desc.float32_desc.precision = 2,
    },
    {
        .id                = PARAM_CLI_TEXT_RGB_STATE,
        .name              = "CLI Text RGB State",
        .which_desc        = cr_ParameterDataType_BIT_FIELD + cr_ParameterInfo_uint32_desc_tag,
        .desc.bitfield_desc.bits_available = 3,
        .desc.bitfield_desc.has_pei_id = true,
        .desc.bitfield_desc.pei_id = 1,
        .access            = cr_AccessLevel_READ_WRITE,
        .storage_location  = cr_StorageLocation_RAM,
        .has_description   = true,
        .description       = "Controls command line color",
    },
    {
        .id                = PARAM_CLI_TEXT_COLOR,
        .name              = "CLI Text Color",
        .which_desc         = cr_ParameterDataType_ENUMERATION + cr_ParameterInfo_uint32_desc_tag,
        .desc.enum_desc.has_pei_id = true,
        .desc.enum_desc.pei_id = 0,
        .access            = cr_AccessLevel_READ_WRITE,
        .storage_location  = cr_StorageLocation_RAM,
        .has_description   = true,
        .description       = "Controls command line color",
    },
    {
        .id                = PARAM_RELATIVE_HUMIDITY,
        .name              = "Relative Humidity",
        .which_desc        = cr_ParameterDataType_FLOAT32 + cr_ParameterInfo_uint32_desc_tag,
        .access            = cr_AccessLevel_READ,
        .storage_location  = cr_StorageLocation_RAM,
        .has_description   = true,
        .description       = "Read from Thunderboard Sensor",
        .desc.float32_desc.has_units        = true,
        .desc.float32_desc.units             = "%",
        .desc.float32_desc.has_range_min     = true,
        .desc.float32_desc.range_min         = 0.01,
        .desc.float32_desc.has_default_value = false,
        .desc.float32_desc.default_value     = 50,
        .desc.float32_desc.has_range_max     = true,
        .desc.float32_desc.range_max         = 100,
        .desc.float32_desc.has_precision = true,
        .desc.float32_desc.precision = 1,
    },
    {
        .id                = PARAM_TEMPERATURE,
        .name              = "Temperature",
        .which_desc        = cr_ParameterDataType_FLOAT32 + cr_ParameterInfo_uint32_desc_tag,
        .access            = cr_AccessLevel_READ,
        .storage_location  = cr_StorageLocation_RAM,
        .has_description   = true,
        .description       = "Read from Thunderboard Sensor",
        .desc.float32_desc.has_units         = true,
        .desc.float32_desc.units             = "\xC2\xB0 C",
        .desc.float32_desc.has_range_min     = true,
        .desc.float32_desc.range_min         = -57,
        .desc.float32_desc.has_default_value = false,
        .desc.float32_desc.default_value     = 20,
        .desc.float32_desc.has_range_max     = true,
        .desc.float32_desc.range_max         = 60,
        .desc.float32_desc.has_precision = true,
        .desc.float32_desc.precision = 1,
    },
    {
        .id                = PARAM_LIGHT_LEVEL,
        .name              = "Light Level",
        .which_desc        = cr_ParameterDataType_FLOAT32 + cr_ParameterInfo_uint32_desc_tag,
        .access            = cr_AccessLevel_READ,
        .storage_location  = cr_StorageLocation_RAM,
        .has_description   = true,
        .description       = "Read from Thunderboard Sensor",
        .desc.float32_desc.has_units         = true,
        .desc.float32_desc.units             = "lux",
        .desc.float32_desc.has_range_min     = true,
        .desc.float32_desc.range_min         = 0,
        .desc.float32_desc.has_default_value = false,
        .desc.float32_desc.default_value     = 300,
        .desc.float32_desc.has_range_max     = true,
        .desc.float32_desc.range_max         = 1000,
        .desc.float32_desc.has_precision = true,
        .desc.float32_desc.precision = 1,
    },
    {
        .id                = PARAM_UV_INDEX,
        .name              = "UV Index",
        .which_desc        = cr_ParameterDataType_FLOAT32 + cr_ParameterInfo_uint32_desc_tag,
        .access            = cr_AccessLevel_READ,
        .storage_location  = cr_StorageLocation_RAM,
        .has_description   = true,
        .description       = "Read from Thunderboard Sensor",
        .desc.float32_desc.has_units         = true,
        .desc.float32_desc.units             = "W/square meter",
        .desc.float32_desc.has_range_min     = true,
        .desc.float32_desc.range_min         = 0.0,
        .desc.float32_desc.has_default_value = false,
        .desc.float32_desc.default_value     = 0,
        .desc.float32_desc.has_range_max     = true,
        .desc.float32_desc.range_max         = 100,
        .desc.float32_desc.has_precision = true,
        .desc.float32_desc.precision = 1,
    },
    {
        .id                = PARAM_MAGNETIC_FIELD_READING,
        .name              = "Magnetic Field Reading",
        .which_desc        = cr_ParameterDataType_FLOAT32 + cr_ParameterInfo_uint32_desc_tag,
        .access            = cr_AccessLevel_READ,
        .storage_location  = cr_StorageLocation_RAM,
        .has_description   = true,
        .description       = "Read from Thunderboard Sensor",
        .desc.float32_desc.has_units         = true,
        .desc.float32_desc.units             = "millitesla",
        .desc.float32_desc.has_range_min     = true,
        .desc.float32_desc.range_min         = -5000.0,
        .desc.float32_desc.has_default_value = false,
        .desc.float32_desc.default_value     = 0,
        .desc.float32_desc.has_range_max     = true,
        .desc.float32_desc.range_max         = 5000,
        .desc.float32_desc.has_precision = true,
        .desc.float32_desc.precision = 0,
    },
    {
        .id                = PARAM_ACCELERATION_X_AXIS,
        .name              = "Acceleration (X axis)",
        .which_desc        = cr_ParameterDataType_FLOAT32 + cr_ParameterInfo_uint32_desc_tag,
        .access            = cr_AccessLevel_READ,
        .storage_location  = cr_StorageLocation_RAM,
        .has_description   = true,
        .description       = "Read from Thunderboard Sensor",
        .desc.float32_desc.has_units         = true,
        .desc.float32_desc.units             = "\xE3\x8E\xA8",
        .desc.float32_desc.has_range_min     = true,
        .desc.float32_desc.range_min         = -50.0,
        .desc.float32_desc.has_default_value = false,
        .desc.float32_desc.default_value     = 0,
        .desc.float32_desc.has_range_max     = true,
        .desc.float32_desc.range_max         = 50,
        .desc.float32_desc.has_precision     = true,
        .desc.float32_desc.precision         = 2,
    },
    {
        .id                = PARAM_ACCELERATION_Y_AXIS,
        .name              = "Acceleration (Y axis)",
        .which_desc        = cr_ParameterDataType_FLOAT32 + cr_ParameterInfo_uint32_desc_tag,
        .access            = cr_AccessLevel_READ,
        .storage_location  = cr_StorageLocation_RAM,
        .has_description   = true,
        .description       = "Read from Thunderboard Sensor",
        .desc.float32_desc.has_units         = true,
        .desc.float32_desc.units             = "\xE3\x8E\xA8",
        .desc.float32_desc.has_range_min     = true,
        .desc.float32_desc.range_min         = -50.0,
        .desc.float32_desc.has_default_value = false,
        .desc.float32_desc.default_value     = 0,
        .desc.float32_desc.has_range_max     = true,
        .desc.float32_desc.range_max         = 50,
        .desc.float32_desc.has_precision     = true,
        .desc.float32_desc.precision         = 2,
    },
    {
        .id                = PARAM_ACCELERATION_Z_AXIS,
        .name              = "Acceleration (Z axis)",
        .which_desc        = cr_ParameterDataType_FLOAT32 + cr_ParameterInfo_uint32_desc_tag,
        .access            = cr_AccessLevel_READ,
        .storage_location  = cr_StorageLocation_RAM,
        .has_description   = true,
        .description       = "Read from Thunderboard Sensor",
        .desc.float32_desc.has_units         = true,
        .desc.float32_desc.units             = "\xE3\x8E\xA8",
        .desc.float32_desc.has_range_min     = true,
        .desc.float32_desc.range_min         = -50.0,
        .desc.float32_desc.has_default_value = false,
        .desc.float32_desc.default_value     = 0,
        .desc.float32_desc.has_range_max     = true,
        .desc.float32_desc.range_max         = 50,
        .desc.float32_desc.has_precision     = true,
        .desc.float32_desc.precision         = 2,
    },
    {
        .id                = PARAM_TIMEZONE_ENABLED,
        .name              = "Timezone Mode",
        .which_desc        = cr_ParameterDataType_BOOL + cr_ParameterInfo_uint32_desc_tag,
        .access            = cr_AccessLevel_READ_WRITE,
        .storage_location  = cr_StorageLocation_NONVOLATILE,
        .desc.bool_desc.has_default_value = true,
        .desc.bool_desc.default_value     = true,
        .desc.bool_desc.has_pei_id        = true,
        .desc.bool_desc.pei_id            = 2,
    },
    {
        .id                = PARAM_TIMEZONE_OFFSET,
        .name              = "Timezone Offset",
        .which_desc         = cr_ParameterDataType_INT32 + cr_ParameterInfo_uint32_desc_tag,
        .access            = cr_AccessLevel_READ_WRITE,
        .storage_location  = cr_StorageLocation_NONVOLATILE,
        .has_description   = true,
        .description       = "The offset from UTC",
        .desc.int32_desc.has_units = true,
        .desc.int32_desc.units             = "seconds",
        .desc.int32_desc.has_range_min     = true,
        .desc.int32_desc.range_min         = -43200,
        .desc.int32_desc.has_default_value = true,
        .desc.int32_desc.default_value     = 0,
        .desc.int32_desc.has_range_max     = true,
        .desc.int32_desc.range_max         = 43200,
    },
    {
        .id                = PARAM_BT_DEVICE_ADDRESS,
        .name              = "BT Device Address",
        .which_desc         = cr_ParameterDataType_BYTE_ARRAY + cr_ParameterInfo_uint32_desc_tag,
        .desc.bytearray_desc.max_size     = 6,
        .access            = cr_AccessLevel_READ,
        .storage_location  = cr_StorageLocation_RAM,
    }
};

const cr_ParamExInfoResponse param_ex_desc[NUM_EX_PARAMS] = {
    {
        .pei_id = 0,
        .data_type = cr_ParameterDataType_ENUMERATION,
        .keys_count = 8,
        .keys = {
            {CLI_TEXT_COLOR_DISABLED, "Disabled"},
            {CLI_TEXT_COLOR_RED,      "Red"},
            {CLI_TEXT_COLOR_GREEN,    "Green"},
            {CLI_TEXT_COLOR_YELLOW,   "Yellow"},
            {CLI_TEXT_COLOR_BLUE,     "Blue"},
            {CLI_TEXT_COLOR_MAGENTA,  "Magenta"},
            {CLI_TEXT_COLOR_CYAN,     "Cyan"},
            {CLI_TEXT_COLOR_WHITE,    "White"}
        }
    },
    {
        .pei_id = 1,
        .data_type = cr_ParameterDataType_ENUMERATION,
        .keys_count = 3,
        .keys = {
            {CLI_TEXT_RGB_STATE_BIT_RED,   "Red"},
            {CLI_TEXT_RGB_STATE_BIT_GREEN, "Green"},
            {CLI_TEXT_RGB_STATE_BIT_BLUE,  "Blue"}
        }
    },
    {
        .pei_id = 2,
        .data_type = cr_ParameterDataType_BOOL,
        .keys_count = 2,
        .keys = {
            {0, "Non-timezoned"},
            {1, "Timezoned"}
    }
    },
    {
        .pei_id = 3,
        .data_type = cr_ParameterDataType_BOOL,
        .keys_count = 2,
        .keys = {
            {0, "Not Identifying"},
            {1, "Identifying"}
        }
    },
    {
        .pei_id = 4,
        .data_type = cr_ParameterDataType_BOOL,
        .keys_count = 2,
        .keys = {
            {0, "Not Pressed"},
            {1, "Pressed"}
        }
    },
    {
        .pei_id = 5,
        .data_type = cr_ParameterDataType_BOOL,
        .keys_count = 2,
        .keys = {
            {0, "Off"},
            {1, "On"}
        }
    },
};

cr_FileInfo file_descriptions[NUM_FILES] = {
    {
        .file_id            = FILE_IO_TXT,
        .file_name          = "io.txt",
        .current_size_bytes = 512,
        .maximum_size_bytes = 2048,
        .access             = cr_AccessLevel_READ_WRITE,
        .storage_location   = cr_StorageLocation_NONVOLATILE,
        .require_checksum   = false,
    },
    {
        .file_id            = FILE_CYGNUS_REACH_LOGO_PNG,
        .file_name          = "cygnus-reach-logo.png",
        .current_size_bytes = 17900,
        .maximum_size_bytes = 17900,
        .access             = cr_AccessLevel_READ,
        .storage_location   = cr_StorageLocation_NONVOLATILE,
        .require_checksum   = false,
    },
    {
        .file_id            = FILE_DEV_NULL,
        .file_name          = "dev_null",
        .current_size_bytes = 100000,
        .maximum_size_bytes = 100000,
        .access             = cr_AccessLevel_READ_WRITE,
        .storage_location   = cr_StorageLocation_RAM,
        .require_checksum   = false,
    }
};

const cr_CommandInfo command_desc[NUM_COMMANDS] = {
    {
        .id   = COMMAND_RESET_DEFAULTS,
        .name = "Reset Defaults",
    },
    {
        .id   = COMMAND_CLICK_FOR_WISDOM,
        .name = "Click for Wisdom",
    },
    {
        .id   = COMMAND_NO_LOGGING,
        .name = "No Logging",
    },
    {
        .id   = COMMAND_MUCH_LOGGING,
        .name = "Much Logging",
    },
    {
        .id   = COMMAND_NOTIFICATIONS_ON,
        .name = "Notifications On",
    },
    {
        .id   = COMMAND_NOTIFICATIONS_OFF,
        .name = "Notifications Off",
    },
    {
        .id   = COMMAND_REMOTE_CLI_ON,
        .name = "remote CLI On",
    },
    {
        .id   = COMMAND_REMOTE_CLI_OFF,
        .name = "remote CLI Off",
    }
};

// The stack will call this function.
// The const copy of the basis in flash is copied to RAM so that the device
// can overwrite varying data like SN and hash.
int crcb_device_get_info(const cr_DeviceInfoRequest *request, cr_DeviceInfoResponse *pDi)
{
    (void) request;
    // The app owns the memory here.
    // The address is returned so that the data can come from flash.
    // memcpy as the structure copy imposes a further address alignment requirement.
    // *pDi = device_info;
    memcpy(pDi, &device_info, sizeof(cr_DeviceInfoResponse));
    I3_LOG(LOG_MASK_REACH, "%s: %s\n", __FUNCTION__, device_info.device_name);

    sprintf(pDi->firmware_version, "%d.%d.%d", APP_MAJOR_VERSION, APP_MINOR_VERSION, APP_PATCH_VERSION);

    snprintf(pDi->device_name, REACH_DEVICE_NAME_LEN, "%s", cr_get_advertised_name());
    return 0;
}

void init_param_repo()
{
    int rval = 0;
    rval = app_handle_param_repo_pre_init();
    if (rval)
    {
        I3_LOG(LOG_MASK_ERROR, "App-specific param repo pre-init failed (error %d), continuing with init", rval);
    }
    memset(sCr_param_val, 0, sizeof(sCr_param_val));
    for (int i=0; i<NUM_PARAMS; i++)
    {
        sCr_param_val[i].parameter_id = param_desc[i].id;

        // the PID directly maps to the parameter type, just to make it easy.
        switch ((param_desc[i].which_desc - cr_ParameterInfo_uint32_desc_tag))
        {
        case cr_ParameterDataType_UINT32:
            if (param_desc[i].desc.uint32_desc.has_default_value)
                sCr_param_val[i].value.uint32_value = param_desc[i].desc.uint32_desc.default_value;
            break;
        case cr_ParameterDataType_INT32:
            if (param_desc[i].desc.int32_desc.has_default_value)
                sCr_param_val[i].value.sint32_value = param_desc[i].desc.int32_desc.default_value;
            break;
        case cr_ParameterDataType_FLOAT32:
            if (param_desc[i].desc.float32_desc.has_default_value)
                sCr_param_val[i].value.float32_value = param_desc[i].desc.float32_desc.default_value;
            break;
        case cr_ParameterDataType_UINT64:
            if (param_desc[i].desc.uint64_desc.has_default_value)
                sCr_param_val[i].value.uint64_value = param_desc[i].desc.uint64_desc.default_value;
            break;
        case cr_ParameterDataType_INT64:
            if (param_desc[i].desc.int64_desc.has_default_value)
                sCr_param_val[i].value.sint64_value = param_desc[i].desc.int64_desc.default_value;
            break;
        case cr_ParameterDataType_FLOAT64:
            if (param_desc[i].desc.float64_desc.has_default_value)
                sCr_param_val[i].value.float64_value = param_desc[i].desc.float64_desc.default_value;
            break;
        case cr_ParameterDataType_BOOL:
            if (param_desc[i].desc.bool_desc.has_default_value)
                sCr_param_val[i].value.bool_value = param_desc[i].desc.bool_desc.default_value;
            break;
        case cr_ParameterDataType_STRING:
            if (param_desc[i].desc.string_desc.has_default_value)
            {
                memset(sCr_param_val[i].value.string_value, 0, sizeof(sCr_param_val[i].value.string_value));
                memcpy(sCr_param_val[i].value.string_value, param_desc[i].desc.string_desc.default_value, sizeof(param_desc[i].desc.string_desc.default_value));
            }
            break;
        case cr_ParameterDataType_ENUMERATION:
            if (param_desc[i].desc.enum_desc.has_default_value)
                sCr_param_val[i].value.enum_value = param_desc[i].desc.enum_desc.default_value;
            break;
        case cr_ParameterDataType_BIT_FIELD:
            if (param_desc[i].desc.bitfield_desc.has_default_value)
                sCr_param_val[i].value.bitfield_value = param_desc[i].desc.bitfield_desc.default_value;
            break;
        case cr_ParameterDataType_BYTE_ARRAY:
            if (param_desc[i].desc.bytearray_desc.has_default_value)
            {
                sCr_param_val[i].value.bytes_value.size = param_desc[i].desc.bytearray_desc.default_value.size;
                memcpy(sCr_param_val[i].value.bytes_value.bytes, param_desc[i].desc.bytearray_desc.default_value.bytes, sizeof(param_desc[i].desc.bytearray_desc.default_value.bytes));
            }
            else
            {
                sCr_param_val[i].value.bytes_value.size = param_desc[i].desc.bytearray_desc.max_size;
                memset(sCr_param_val[i].value.bytes_value.bytes, 0, sCr_param_val[i].value.bytes_value.size);
            }
            break;
        default:
            affirm(0);  // should not happen.
            break;
        }  // end switch

        // Convert from description type identifier to value type identifier
        sCr_param_val[i].which_value = (param_desc[i].which_desc - cr_ParameterInfo_uint32_desc_tag) + cr_ParameterValue_uint32_value_tag;

        if (param_desc[i].storage_location == cr_StorageLocation_STORAGE_LOCATION_INVALID || param_desc[i].storage_location > cr_StorageLocation_NONVOLATILE_EXTENDED)
        {
          I3_LOG(LOG_MASK_ERROR, "At param index %d, invalid storage location %d.",
                 i, param_desc[i].storage_location);
        }

        rval = app_handle_param_repo_init(&sCr_param_val[i], &param_desc[i]);
        if (rval != 0)
            I3_LOG(LOG_MASK_ERROR, "At param index %d, failed to initialize data (error %d)", i, rval);

    } // end for
    rval = app_handle_param_repo_post_init();
    if (rval)
    {
        I3_LOG(LOG_MASK_ERROR, "App-specific param repo pre-init failed (error %d), continuing with init", rval);
    }
}

// Populate a parameter value structure
int crcb_parameter_read(const uint32_t pid, cr_ParameterValue *data)
{
    affirm(data != NULL);
    if (pid >= NUM_PARAMS)
        return cr_ErrorCodes_INVALID_PARAMETER;
    int rval = app_handle_param_repo_read(&sCr_param_val[pid]);
    *data = sCr_param_val[pid];
    return rval;
}

int crcb_parameter_write(const uint32_t pid, const cr_ParameterValue *data)
{   
    if (pid >= NUM_PARAMS)
        return cr_ErrorCodes_INVALID_PARAMETER;
    int rval = 0;
    I3_LOG(LOG_MASK_PARAMS, "Write param, pid %d (%d)", pid, data->parameter_id);
    I3_LOG(LOG_MASK_PARAMS, "  timestamp %d", data->timestamp);
    I3_LOG(LOG_MASK_PARAMS, "  which %d", data->which_value);
    rval = app_handle_param_repo_write((cr_ParameterValue *) data);
    if (rval != 0)
    {
        // Invalid data or NVM storage failed
        return rval;
    }
    sCr_param_val[pid].timestamp = data->timestamp;
    sCr_param_val[pid].which_value = data->which_value;

    switch ((data->which_value - cr_ParameterValue_uint32_value_tag))
    {
        case cr_ParameterDataType_UINT32:
            sCr_param_val[pid].value.uint32_value = data->value.uint32_value;
            break;
        case cr_ParameterDataType_INT32:
            sCr_param_val[pid].value.sint32_value = data->value.sint32_value;
            break;
        case cr_ParameterDataType_FLOAT32:
            sCr_param_val[pid].value.float32_value = data->value.float32_value;
            break;
        case cr_ParameterDataType_UINT64:
            sCr_param_val[pid].value.uint64_value = data->value.uint64_value;
            break;
        case cr_ParameterDataType_INT64:
            sCr_param_val[pid].value.sint64_value = data->value.sint64_value;
            break;
        case cr_ParameterDataType_FLOAT64:
            sCr_param_val[pid].value.float64_value = data->value.float64_value;
            break;
        case cr_ParameterDataType_BOOL:
            sCr_param_val[pid].value.bool_value = data->value.bool_value;
            break;
        case cr_ParameterDataType_STRING:
            memcpy(sCr_param_val[pid].value.string_value,
                   data->value.string_value, REACH_PVAL_STRING_LEN);
            sCr_param_val[pid].value.string_value[REACH_PVAL_STRING_LEN-1] = 0;
            I3_LOG(LOG_MASK_PARAMS, "String value: %s",
                   sCr_param_val[pid].value.string_value);
            break;
        case cr_ParameterDataType_BIT_FIELD:
            sCr_param_val[pid].value.bitfield_value = data->value.bitfield_value;
            break;
        case cr_ParameterDataType_ENUMERATION:
            sCr_param_val[pid].value.enum_value = data->value.enum_value;
            break;
        case cr_ParameterDataType_BYTE_ARRAY:
            memcpy(sCr_param_val[pid].value.bytes_value.bytes,
                   data->value.bytes_value.bytes, 
                   REACH_PVAL_BYTES_LEN);
            if (data->value.bytes_value.size > REACH_PVAL_BYTES_LEN)
            {
                LOG_ERROR("Parameter write of bytes has invalid size %d > %d",
                          data->value.bytes_value.size, REACH_PVAL_BYTES_LEN);
                sCr_param_val[pid].value.bytes_value.size = REACH_PVAL_BYTES_LEN;
            }
            else
            {
                sCr_param_val[pid].value.bytes_value.size = data->value.bytes_value.size;
            }
            LOG_DUMP_MASK(LOG_MASK_PARAMS, "bytes value",
                          sCr_param_val[pid].value.bytes_value.bytes,
                          sCr_param_val[pid].value.bytes_value.size);
            break;
        default:
            LOG_ERROR("Parameter write which_value %d not recognized.", 
                          data->which_value);
            rval = 1;
            break;
    }  // end switch
    return rval;
}


int crcb_parameter_get_count()
{
    int i;
    int numAvailable = 0;
    for (i=0; i<NUM_PARAMS; i++)
    {
        if (crcb_access_granted(cr_ServiceIds_PARAMETER_REPO, param_desc[i].id))
            numAvailable++;
    }
    return numAvailable;
}

// return a number that changes if the parameter descriptions have changed.
uint32_t crcb_compute_parameter_hash(void)
{
    // Note that the layout of the structure param_desc differs by compiler.
    // The hash computed on windows won't match that computed on SiLabs.
    uint32_t *ptr = (uint32_t*)param_desc;
    size_t sz = sizeof(param_desc)/(sizeof(uint32_t));
    // LOG_DUMP_MASK(LOG_MASK_PARAMS, "Raw Params", cptr, sizeof(param_desc));

    // The hash should be different based on access permission
    uint32_t hash = 0;
    for (size_t jj = 0; jj < NUM_PARAMS; jj++)
    {
        if (crcb_access_granted(cr_ServiceIds_PARAMETER_REPO, jj))
        {
            for (size_t i= 0; i<sizeof(cr_ParameterInfo); i++)
                hash ^= ptr[i];
        }
    }

#ifdef NUM_EX_PARAMS
    ptr = (uint32_t*)param_ex_desc;
    size_t sz1 = sizeof(param_ex_desc)/(sizeof(uint32_t));

    for (size_t i= 0; i<sz1; i++)
        hash ^= ptr[i];

    I3_LOG(LOG_MASK_PARAMS, "%s: hash 0x%x over %d+%d = %d words.\n",
           __FUNCTION__, hash, sz, sz1, sz+sz1);
#else
    I3_LOG(LOG_MASK_PARAMS, "%s: hash 0x%x over %d words.\n",
           __FUNCTION__, hash, sz);
#endif // NUM_EX_PARAMS

    return hash;
}

static int sCurrentParameter = 0;

// Resets the application's pointer into the parameter table such that
// the next call to crcb_parameter_discover_next() will return the
// description of this parameter.
int crcb_parameter_discover_reset(const uint32_t pid)
{
    if (pid >= NUM_PARAMS)
    {
        sCurrentParameter = 0;
        I3_LOG(LOG_MASK_PARAMS, "dp reset(%d) reset defaults to %d", pid, sCurrentParameter);
        return cr_ErrorCodes_INVALID_PARAMETER;
    }
    sCurrentParameter = pid;
    int i;
    sCurrentParameter = 0;  // in case none match
    for (i = 0; i < NUM_PARAMS; i++)
    {
        if (param_desc[i].id == pid) {
            sCurrentParameter = i;
            I3_LOG(LOG_MASK_PARAMS, "dp reset(%d) reset to %d", pid, sCurrentParameter);
            return 0;
        }
    }
    I3_LOG(LOG_MASK_PARAMS, "dp reset(%d) reset defaults to %d", pid, sCurrentParameter);
    return cr_ErrorCodes_INVALID_PARAMETER;
}

// Gets the parameter description for the next parameter.
// Allows the stack to iterate through the parameter list.
// The caller provides a cr_ParameterInfo containing string pointers that will be overwritten.
// The app owns the string pointers which must not be on the stack.
int crcb_parameter_discover_next(cr_ParameterInfo *ppDesc)
{
    if (sCurrentParameter >= NUM_PARAMS)
    {
        I3_LOG(LOG_MASK_PARAMS, "%s: sCurrentParameter (%d) >= NUM_PARAMS (%d)",
               __FUNCTION__, sCurrentParameter, NUM_PARAMS);
        return cr_ErrorCodes_NO_DATA;
    }
    while (!crcb_access_granted(cr_ServiceIds_PARAMETER_REPO, param_desc[sCurrentParameter].id))
    {
        I3_LOG(LOG_MASK_PARAMS, "%s: sCurrentParameter (%d) skip, access not granted",
                   __FUNCTION__, sCurrentParameter);
        sCurrentParameter++;
        if (sCurrentParameter >= NUM_PARAMS)
        {
            I3_LOG(LOG_MASK_PARAMS, "%s: skipped to sCurrentParameter (%d) >= NUM_PARAMS (%d)",
                   __FUNCTION__, sCurrentParameter, NUM_PARAMS);
            return cr_ErrorCodes_NO_DATA;
        }
    }
    *ppDesc = param_desc[sCurrentParameter];
    sCurrentParameter++;
    return 0;
}

// In parallel to the parameter discovery, use this to find out 
// about enumerations and bitfields
static int sCurrentExParam = 0;
static int sRequestedParamPid = -1; // negative means all

int crcb_parameter_ex_get_count(const int32_t pid)
{
#ifdef NUM_EX_PARAMS
    if (pid < 0)  // all 
        return NUM_EX_PARAMS;

    int num_ex_msgs = 0;

    for (int i=0; i<NUM_EX_PARAMS; i++) {
        if ((int32_t)param_ex_desc[i].pei_id == pid) {
            num_ex_msgs++;
        }
    }
    return num_ex_msgs;
#else
    return 0;
#endif // NUM_EX_PARAMS
}

int crcb_parameter_ex_discover_reset(const int32_t pid)
{
    // unlike the full params, reset of param_ex always goes to zero.
    sCurrentExParam = 0;
    sRequestedParamPid = pid;
    return 0;
}

int crcb_parameter_ex_discover_next(cr_ParamExInfoResponse *pDesc)
{
    affirm(pDesc);
    pDesc->keys_count = 0;
#ifdef NUM_EX_PARAMS
    if (sCurrentExParam>=NUM_EX_PARAMS)
    {
        I3_LOG(LOG_MASK_PARAMS, "%s: No more ex params.", __FUNCTION__);
        return cr_ErrorCodes_INVALID_PARAMETER;
    }

    if (sRequestedParamPid < 0)
    {
        I3_LOG(LOG_MASK_PARAMS, "%s: For all, return param_ex %d.", __FUNCTION__, sCurrentExParam);
        *pDesc = param_ex_desc[sCurrentExParam];
        sCurrentExParam++;
        return 0;
    }

    for (int i=sCurrentExParam; i<NUM_EX_PARAMS; i++)
    {
        if ((int32_t)param_ex_desc[i].pei_id == sRequestedParamPid)
        {
            I3_LOG(LOG_MASK_PARAMS, "%s: For pid %d, return param_ex %d.",
                   __FUNCTION__, sRequestedParamPid, sCurrentExParam);
            *pDesc = param_ex_desc[i];
            sCurrentExParam = i+1;;
            return 0;
        }
    }
    // should not get here.
    I3_LOG(LOG_MASK_PARAMS, "%s: No more ex params 2.", __FUNCTION__);
#endif // NUM_EX_PARAMS
    return cr_ErrorCodes_INVALID_PARAMETER;
}

int crcb_file_get_description(uint32_t fid, cr_FileInfo *file_desc)
{
    if (fid > NUM_FILES)
        return cr_ErrorCodes_BAD_FILE;
    *file_desc = file_descriptions[fid];
    return 0;
}

int crcb_file_get_file_count()
{
    int i;
    int numAvailable = 0;
    for (i=0; i<NUM_FILES; i++)
    {
        if (crcb_access_granted(cr_ServiceIds_FILES, file_descriptions[i].file_id))
            numAvailable++;
    }
    return numAvailable;
}

static uint8_t sFid_index = 0;
int crcb_file_discover_reset(const uint8_t fid)
{
    if (fid > NUM_FILES)
    {
        I3_LOG(LOG_MASK_ERROR, "crcb_file_discover_reset(%d): invalid FID, using 0.", fid);
        sFid_index = 0;
        return cr_ErrorCodes_BAD_FILE;
    }
    sFid_index = 0;
    for (sFid_index = 0; sFid_index < NUM_FILES; sFid_index++)
    {
        if (file_descriptions[sFid_index].file_id == fid)
        {
            if (!crcb_access_granted(cr_ServiceIds_FILES, file_descriptions[sFid_index].file_id))
            {
                sFid_index = 0;
                break;
            }
            return 0;
        }
    }
    sFid_index = crcb_file_get_file_count();
    I3_LOG(LOG_MASK_PARAMS, "discover file reset (%d) reset defaults to %d", fid, sFid_index);
    return cr_ErrorCodes_INVALID_PARAMETER;
}

int crcb_file_discover_next(cr_FileInfo *file_desc)
{
    if (sFid_index >= NUM_FILES)
    {
        // I3_LOG(LOG_MASK_WARN, "%s: sFid_index (%d) >= NUM_FILES (%d)",
        //        __FUNCTION__, sFid_index, NUM_FILES);
        return cr_ErrorCodes_NO_DATA;
    }

    while (!crcb_access_granted(cr_ServiceIds_FILES, file_desc[sFid_index].file_id))
    {
        I3_LOG(LOG_MASK_FILES, "%s: sFid_index (%d) skip, access not granted",
                   __FUNCTION__, sFid_index);
        sFid_index++;
        if (sCurrentParameter >= NUM_FILES)
        {
            I3_LOG(LOG_MASK_PARAMS, "%s: skipped to sFid_indexsFid_index (%d) >= NUM_FILES (%d)",
                   __FUNCTION__, sFid_index, NUM_FILES);
            return cr_ErrorCodes_NO_DATA;
        }
    }
    *file_desc = file_descriptions[sFid_index++];
    return 0;
}


uint8_t sCommandIndex = 0;

int crcb_get_command_count()
{
    int i;
    int numAvailable = 0;
    for (i=0; i<NUM_COMMANDS; i++)
    {
        if (crcb_access_granted(cr_ServiceIds_COMMANDS, command_desc[i].id))
            numAvailable++;
    }
    return numAvailable;
}

int crcb_command_discover_next(cr_CommandInfo *cmd_desc)
{
    if (sCommandIndex >= NUM_COMMANDS)
    {
        I3_LOG(LOG_MASK_REACH, "%s: Command index %d indicates discovery complete.",
               __FUNCTION__, sCommandIndex);
        return cr_ErrorCodes_NO_DATA;
    }

    while (!crcb_access_granted(cr_ServiceIds_COMMANDS, command_desc[sCommandIndex].id))
    {
        I3_LOG(LOG_MASK_FILES, "%s: sCommandIndex (%d) skip, access not granted",
                   __FUNCTION__, sFid_index);
        sFid_index++;
        if (sCurrentParameter >= NUM_COMMANDS)
        {
            I3_LOG(LOG_MASK_PARAMS, "%s: skipped to sCommandIndex (%d) >= NUM_COMMANDS (%d)",
                   __FUNCTION__, sFid_index, NUM_COMMANDS);
            return cr_ErrorCodes_NO_DATA;
        }
    }
    *cmd_desc = command_desc[sCommandIndex++];
    return 0;
}

int crcb_command_discover_reset(const uint32_t cid)
{
    if (cid >= NUM_COMMANDS)
    {
        i3_log(LOG_MASK_ERROR, "%s: Command ID %d does not exist.",
               __FUNCTION__, cid);
        return cr_ErrorCodes_INVALID_PARAMETER;
    }

    for (sCommandIndex = 0; sCommandIndex < NUM_COMMANDS; sCommandIndex++)
    {
        if (command_desc[sCommandIndex].id == cid) {
            if (!crcb_access_granted(cr_ServiceIds_COMMANDS, command_desc[sCommandIndex].id))
            {
                sFid_index = 0;
                break;
            }
            I3_LOG(LOG_MASK_PARAMS, "discover command reset (%d) reset to %d", cid, sCurrentParameter);
            return 0;
        }
    }
    sCommandIndex = crcb_get_command_count();
    I3_LOG(LOG_MASK_PARAMS, "discover command reset (%d) reset defaults to %d", cid, sCurrentParameter);
    return cr_ErrorCodes_INVALID_PARAMETER;
}

int __attribute__((weak)) app_handle_param_repo_pre_init(void)
{
    return 0;
}
int __attribute__((weak)) app_handle_param_repo_init(cr_ParameterValue *data, const cr_ParameterInfo *desc)
{
    (void) desc;
    return app_handle_param_repo_read(data);
}

int __attribute__((weak)) app_handle_param_repo_post_init(void)
{
    return 0;
}

int __attribute__((weak)) app_handle_param_repo_read(cr_ParameterValue *data)
{
    (void) data;
    return 0;
}

int __attribute__((weak)) app_handle_param_repo_write(cr_ParameterValue *data)
{
    (void) data;
    return 0;
}
